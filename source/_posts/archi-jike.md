---
title: archi-jike
date: 2020-04-05 07:53:24
tags:
---

### 简介
- 软件架构是有关软件整体结构与组件的抽象描述，用于指导软件系统各个方面的设计
- 目标
  - 高性能
  - 高可用
  - 可扩展
- 分层
  - 访问层
  - 网关层
  - 服务层
  - 存储层
  - 监控/限流/降级
### 分层
- 目的
  - 分而治之
  - 各司其职
- 常见分层
  - 计算机OSI7层模型
  - web系统的mvc/mvvm模型
  - 基于领域模型的分层(电商系统...)
- 演进
  - servletJSP时代
    - servlet+tomcat完成web接入
    - javaBean+JDBC完成数据层接入
    - JSP完成页面展示
  - SSH
    - strutsMVC完成web接入JSP完成表示层
    - spring完成业务逻辑/会话管理
    - hibernate完成数据存储接入和持久化
  - SSM
    - springMVC更适用前后端分离
    - spring支持注解/配置声明式事务处理
    - mybatis配置缓存/解耦数据库对象和java对象
  - SpringBoot
    - 整合了spring所有框架，提供allInOne服务
    - 提供简单的配置和注解的接入方式
  - 分布式分层
- 亿级流量平台分层架构
  - 功能
    - 水平扩展
    - 负载均衡
    - 高可用
    - 数据一致性
  - 分层(需要每一层都能分布式)
    - 访问层，用于web接入/反向代理/负载均衡
    - 网关层，用于业务api
    - 服务层，具备服务治理/调度/异步通信等
    - 存储层(存储接入层/存储层)，用于提供透明的存储结构的访问代理和数据落地能力

### 访问层
- lvs
  - 采用ip负载均衡技术和基于内容请求分发技术做的负载均衡
  - 概念
    - CIP clientIP
    - DIP directorIP
    - RIP realServerIP
  - 模式
    - NAT
      - networkAddressTranslation网络地址转换
      - CIP->DIP->RIP->DIP->CIP(lvs两次SNAT/DNAT)
      - 进出流量都走lvs,部署和配置比较简单，但lvs始终要维护两端的socket连接,可能会成为瓶颈
    - DR
      - directRouting直接路由
      - CIP->DIP->RIP->CIP(要修改DIP->RIP时的mac地址)
      - 响应流量不走lvs,减少lvs始终维护两端socket的性能开销,但要求DIP和RIP要在同一机房
      - 通常使用此模式，在同一机房也会有很高的性能
    - TUN
      - tunneling隧道
      - CIP->DIP->RIP->CIP(在DIP发送到RIP时做了二次封装,RIP拿到包后要二次解析)
      - 响应流量不走lvs,同时DIP和RIP也不一定要在同一机房,但要求RS必须支持隧道模式即要二次解析IP包
  - 调度策略
    - 轮询/权重轮询
    - 最少连接/权重最少连接
    - ip_hash/ip_hash_group/url_hash/url_hash_group...
  - 优势
    - ip层的负载均衡,没有应用层回调的消耗，性能高
    - 通过DR/TUN模式使响应不走lvs
    - 支持后端心跳检测,自动故障转移恢复
    - 配合主从keepAlive和VIP实现自身高可用
- nginx
  - 功能
    - 请求解析(http/https)
    - 负载均衡(应用层)
    - 缓存调度
    - 授权认证
    - 接入处理(过滤非法请求)
    - 业务逻辑
    - 响应处理
    - 压缩技术
  - 职责分类
    - 接入层nginx
    - 应用层nginx(缓存调度/业务逻辑/限流降级)
  - 高性能原因
    - master-worker进程模型
      - master进程系统调用
        - socket()
        - bind()
        - listen()
        - fork()
      - worker进程系统调用
        - accept()
        - recv()
        - send()
        - close()
    - 异步模型
      - select(缺点:只能并发1024个请求/低效的遍历性能消耗)
      - epoll(linux2.6后实现的事件机制,解决了上面2个问题)
    - 流式处理请求workflow,有主子请求
    - 协程机制解决worker上不能有阻塞操作
      - 协程
        - 栈/局部变量在用户空间模拟，切换开销小
        - 协程间是协作关系
        - 临界区不需要加锁
        - 遇到阻塞主动放弃切换
      - 线程
        - 栈/局部变量是内核空间的映射，切换开销大
        - 多线程并发运行是竞争cpu关系
        - 临界区需要同步加锁
        - 遇到阻塞进入等待cpu切换
    - nginx lua
  - 具体应用
    - 负载均衡
      - upstream
      - proxy_pass
    - 代理缓存(先要有后端的代理才能使用代理缓存)
      - proxy_cache_path PATH levels=1:2 keys_zone=NAME:100m inactive=7d max_size=100g;
        - 把缓存文件放在PATH中
        - levels=1:2 缓存文件目录层级和目录名称长度
        - keys_zone 指定了一个内存空间，并设置大小来缓存key与缓存文件目录的映射关系
        - inactive=7d 缓存文件7天后失效淘汰
        - max_size=100g 缓存文件总大小超过100g后释放淘汰
      - 使用
        - proxy_cache NAME; # 使用缓存空间
        - proxy_cache_valid 200 206 302 304 10d; # 后端返回以下响应码时缓存多久
        - proxy_cache_key $uri; # 一般使用$uri作为缓存的key;

### 网关层
- 分布式会话管理
  - 会话机制
    - session
      - 通过判断SID里是否包含用户信息判定用户是否登陆
      - 依赖后端的session容器和前端的cookie，无法解决cookie跨域和禁用的问题
    - cookie
      - 后端验证用户信息后将凭证做数字签名，加密后写入cookie的ticket，验证时取出ticket解密判断
      - 不依赖后端session容器但也没有解决cookie跨域和禁用的问题
    - token
      - 后端验证用户信息后将凭证做数字签名，加密后写入token返回前端，前端请求时参数或header中携带token
      - 不依赖cookie，但需要请求时携带token
  - 安全问题
    - cookie被劫持，xss/csrf安全攻击
    - token凭证被劫持，伪造
  - 解决方式
    - https
    - 风控系统主动失效及过期机制
  - 分布式会话管理
    - 登陆凭证放入集中的会话管理redis/memcached
    - 对应session的处理机制要重写
- 接入层控制
  - 控制内容
    - 身份验证
      - 通过会话管理获取用户登陆凭证
      - 通过用户凭证获取用户信息
      - 验证对应的url/资源是否可以被用户访问
    - 流量控制
      - 对应url流量是否可以被承载否则限流(filter的pre/post进行计数即可实现)
      - 对应服务分级的流量是否被承载
      - 对应整个系统的总流量是否被承载
    - 路由服务
      - 根据url规则找到对应的服务
      - 判断服务的状态，做服务路由调用
    - 记录调试或统计信息
  - 通过接入层框架的通用的filter功能实现
    - javaServletFilter
    - springMVCHandlerInterceptor
    - zuulFilter
- 服务调用及聚合
  - 如果需要多个后端服务调用则需要在网关层这里做聚合
  - 分类
    - 重接入
      - springMVC+dubbo
      - 优点：可灵活的在controller层处理业务逻辑，聚合服务
      - 缺点：服务的单一性不够，后端服务不便管理
    - 轻接入
      - zuul
      - 优点：服务单一，接入控制可以页面配置
      - 缺点：聚合能力不够，需要后端提供

### 核心服务层之服务通信
- 微服务
  - 传统服务缺点
    - 所有服务耦合在一起
    - 隔离型弱，互相影响
    - 部署臃肿
    - 开发维护困难
  - 微服务
    - 特性
      - 高内聚,低耦合,专注自己的核心业务
      - 隔离型强,不会相互影响(进程上)
      - 轻量的通信机制
      - 独立开发,单独部署
    - 需要解决的问题
      - 服务治理(服务注册和发现,负载均衡和智能容错,服务监控和健康管理,限流降级熔断)
      - 数据一致性
      - 调用性能
      - 研发流程调试,部署,测试
- dubbo服务治理
  - 来解决微服务服务治理的轻量级开源javaRPC框架
  - 核心能力
    - 面向接口的远程方法调用
    - 服务自动注册和发现
    - 负载均衡和智能容错
- 异步消息服务
  - 分类
    - JMS(apacheActiveMQ)
    - Kafka(流式处理)
    - RocketMQ(alibaba基于Kafka开发的分布式一致性服务)
  - JMS
    - javaMessageService
    - 特点
      - 点对点(每个消息都被发送到特定的队列,接收者从队列中顺序消费,队列保留着消息直到被消费或超时)
      - 发布订阅(客户端将消息发到主题,消息队列存放主题,订阅者消费主题)
    - activeMQ缺点
      - 以消息为单位,为保证消息稳定性需要落盘,但可能落盘时不连续,磁盘寻值有性能问题
      - 消费时是推模式,对consumer的线程压力非常大
  - Kafka
    - 默认支持点对点，但不常用，常用发布订阅
    - 客户端将消息发到主题,消息队列存放主题,订阅者消费主题,消息持久化到队尾,消费通过客户端指针,吞吐量高
    - 比activeMQ优点
      - 引入broker概念把相同topic的消息连续的落到同一个文件,保证磁盘IO性能
      - 消费时是拉模式,根据consumer性能决定消费速度
      - 引入了nameServer类似zookeeper的组件和队列/失败重试队列来保证消息稳定可靠
  - RocketMQ
    - 结合了Kafka和ActiveMQ的优点,把Kafka很多的api封装成类似ActiveMQ简单易用
    - 消息队列维护高可用,并支持事务回溯机制(增加了prepare队列)

### 核心服务层之调度/池化
- 任务调度
  - 应用场景
    - 业务跑批轮询等待处理
    - 失败的异常重试
    - 定时任务处理
  - 单机实现方式
    - Timer定时器机制
      - java自带，比较简单
      - 所有任务都在同一个线程中串行执行，同一时间只能执行一个任务，不适合多线程并发多任务
    - ScheduledExecutor
      - 内置了线程池，解决Timer单线程的问题
      - 任务数不能超过线程池数，否则也会相互影响
    - Quartz
      - 包含任务JobDetail类和调度Trigger类
      - 定时检测到任务后Job会在线程池中申请线程执行
  - 分布式调度方式及实现
    - Quartz分布式版本
      - 部署机器的时间一致
      - 部署的代码一致
      - 需要中间层同步竞争锁(数据库)
    - Elasticsearch-Job分片分布式
      - 借鉴了竞争锁的机制,不过使用zookeeper实现
      - 自己实现了任务是否分片，解决大job问题
- 池化技术
  - 通过复用减少系统消耗，提升系统性能
  - 分类
    - 对象池
      - 利用复用对象减少创建对象/垃圾回收的开销
      - 例如线程池通过复用线程提升性能
    - 连接池
      - 数据库连接池/redis连接池/http连接池
      - 通过复用tcp连接减少创建和释放连接的时间
  - 实战
    - java线程池
      - 核心/最小线程数大小(任务进来后首选核心线程)
      - 等待队列长度(核心线程都busy时新进的任务进等待队列)
      - 最大线程数大小(等待队列也满了又有新进的任务则开启新线程,等待队列出对执行)
      - 拒绝策略(达到最大线程后又有新进的任务则会按拒绝策略执行,分为被动等待或直接报错)
      - idle等待时间(弹性线程空闲等待时间后会回收)
    - 连接池(数据库/redis/httpClient)
      - 连接状态
        - init
        - connect
        - busy
        - close
      - 核心连接数
      - 最大连接数
      - 连接等待时间(tcp/ip建连时间)
      - 数据读取时间
      - idle等待时间(弹性连接空闲等待时间后会释放)
      - validate
        - 获取连接时
        - 使用连接时(常用)
        - 释放连接时
    - tomcat线程/连接池
      - 客户端连接池
      - io线程池
      - worker线程池

### 核心服务层之缓存/隔离/队列
- 缓存
  - 设计原则
    - 存储设备读写速度最快(cpu/内存)
    - 数据离应用最近(业务服务器/局域网/机房)
    - 数据离用户最近(app/CDN/nginx缓存/api网关/核心业务redis)
  - 分类
    - CDN缓存
    - 反向代理缓存 nginxProxyCache
    - 分布式缓存 redis
    - 本地应用缓存 JVM Guava
- 隔离
  - 硬件隔离(虚拟机)
  - 操作系统隔离(容器虚拟化)
  - 进程隔离(系统拆分)
  - 线程隔离(线程池独立)
  - 读写隔离
  - 动静隔离
  - 冷热隔离(热点账户/热点数据)
- 队列
  - 先进先出的线性表
  - 用途
    - 异步处理
    - 系统解耦
    - 流量削峰
      - 排队有时候会比并发效率更高
      - 排队可以控制并发流量开关/大小

### 数据存储层
- 数据存储
  - 分类
    - 传统IT
      - excel提供简单的关系存储
      - 磁盘提供文件存储
      - sql数据库提供关系型存储
    - 互联网行业
      - 分布式存储需要无限可扩展的网络文件系统
      - 关系型数据库需要提供事务一致性的保证
      - 非关系型数据库需要提供更高性能的简化存储
      - 磁盘和内存需要性能和稳定中间权衡
  - 数据结构
    - 结构化数据(表,有完备的模式)
    - 非结构化数据(音视频文件等)
    - 半结构化数据(xml表示简历格式)
  - 数据库结构
    - 关系型数据库
    - 非关系型数据库
  - 选型
    - 非结构化数据选择网络文件系统/网络磁盘
    - 结构化数据根据是否需要SQL和关系事务的支持
      - 关系型数据库
      - 非关系型数据库(磁盘非关系/内存非关系)
    - 半结构化数据
      - 首先使用XML或JSON等可扩展的结构化数据进行描述
      - 然后根据是否落地选择非关系型数据库
  - 常用
    - NAS 
      - network attached storage网络附属存储
      - 网络文件系统,基底层设备,提供文件磁盘
      - 有cpu/内存/网络接入端口/磁盘插槽
    - OSS
      - object storage service
      - 基于bucket管理网络文件
- 关系型与非关系型
  - 关系型数据库mysql
    - 关系型存储格式,如表
    - 非主键字段依赖索引提高查询速度,查询需要快照和锁机制
    - 事务保障效率高
      - set autocommit=0;
      - begin;
      - SQL;
      - commit;
    - 可以使用join进行复杂查询
  - 非关系型数据库mongoDB
    - kv存储格式
    - 通常使用k查询,对应关系型的主键,比索引更快,大多使用单线程存储,无需锁
    - 没有事务的概念
    - 对复杂查询的能力较弱但场景也比较少
    - mongoDB
      - 是非关系型数据库中功能最丰富,最像关系型数据库的非关系型数据库
      - 数据结构非常松散,类似JSON的BSON格式
      - db.NAME.find().pretty()/insert()/update()/remove()/createIndex()/sort()/limit()/skip()
    - redis
      - 用作数据库/高速缓存/消息队列代理
      - 支持字符串/哈希表/列表/集合/有序集合/位图等数据类型
      - 内置复制/LRU淘汰回收/事务及不同级别的磁盘持久化功能
      - 通过Redis Sentinel提供高可用
      - 通过Redis Cluster提供自动分区
- 代理访问层
  - 代理对象分类
    - nginx反向代理
    - mycat代理mysql
    - twemproxy代理redis/redis4自带的redisCluster也可支持代理
  - 代理作用
    - 集中收口
    - 负载均衡
    - 故障转移
    - 路由策略
    - 缓存策略

### 监控/限流/降级
- 监控
  - 指标
    - 硬件(zabbix监控)
      - CpuIdleTime
      - FreeMemory
      - IOWait
      - NetworkFree
    - 软件(cat heartbeat监控)
      - CpuLoadAverage
      - ParNewCount
      - ParNewTime
      - OldGCCount
      - OldGCTime
    - 接口(cat transaction监控)
      - url/dubbo failure times
      - 9X线(95%Line/99.9%Line/99.99%Line)
    - 异常(cat exception监控)
      - ExceptionTimesAndContent
    - 大盘(cat 大盘监控)
      - 基线成功率
      - 基线失败率
- 限流
  - 原因
    - 流量远比能力大
    - 永远不知道对方会怎么样
    - 永远不知道自己会怎么样
  - 维度
    - url(外部接口)
    - dubbo接口(内部接口)
    - sql操作数
  - 内容
    - TPS/QPS
    - 限制并发数
    - 限制总数
  - 算法原理
    - 限制并发数(服务内以接口为单位设置并发总数锁,超过并发总数返回异常,达到限制并发的功能)
    - 令牌桶算法(以桶模拟对应的令牌池,定时器会根据TPS重置桶,达到限制TPS的功能)
    - 漏桶算法(以固定的速度流出流量,可以应对一定程度的突发流量,达到削峰填谷的功能)
  - 实战
    - Guava的ratelimiter实现令牌桶
- 降级
  - 保护系统正常运行,也要保证用户体验
  - 策略
    - 关闭接口并设置默认返回
    - 降级逻辑
    - 主动降级