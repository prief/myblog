---
title: archi-jike
date: 2020-04-05 07:53:24
tags:
---

### 简介
- 软件架构是有关软件整体结构与组件的抽象描述，用于指导软件系统各个方面的设计
- 目标
  - 高性能
  - 高可用
  - 可扩展
- 分层
  - 访问层
  - 网关层
  - 服务层
  - 存储层
  - 监控/限流/降级
### 分层
- 目的
  - 分而治之
  - 各司其职
- 常见分层
  - 计算机OSI7层模型
  - web系统的mvc/mvvm模型
  - 基于领域模型的分层(电商系统...)
- 演进
  - servletJSP时代
    - servlet+tomcat完成web接入
    - javaBean+JDBC完成数据层接入
    - JSP完成页面展示
  - SSH
    - strutsMVC完成web接入JSP完成表示层
    - spring完成业务逻辑/会话管理
    - hibernate完成数据存储接入和持久化
  - SSM
    - springMVC更适用前后端分离
    - spring支持注解/配置声明式事务处理
    - mybatis配置缓存/解耦数据库对象和java对象
  - SpringBoot
    - 整合了spring所有框架，提供allInOne服务
    - 提供简单的配置和注解的接入方式
  - 分布式分层
- 亿级流量平台分层架构
  - 功能
    - 水平扩展
    - 负载均衡
    - 高可用
    - 数据一致性
  - 分层(需要每一层都能分布式)
    - 访问层，用于web接入/反向代理/负载均衡
    - 网关层，用于业务api
    - 服务层，具备服务治理/调度/异步通信等
    - 存储层(存储接入层/存储层)，用于提供透明的存储结构的访问代理和数据落地能力

### 访问层
- lvs
  - 采用ip负载均衡技术和基于内容请求分发技术做的负载均衡
  - 概念
    - CIP clientIP
    - DIP directorIP
    - RIP realServerIP
  - 模式
    - NAT
      - networkAddressTranslation网络地址转换
      - CIP->DIP->RIP->DIP->CIP(lvs两次SNAT/DNAT)
      - 进出流量都走lvs,部署和配置比较简单，但lvs始终要维护两端的socket连接,可能会成为瓶颈
    - DR
      - directRouting直接路由
      - CIP->DIP->RIP->CIP(要修改DIP->RIP时的mac地址)
      - 响应流量不走lvs,减少lvs始终维护两端socket的性能开销,但要求DIP和RIP要在同一机房
      - 通常使用此模式，在同一机房也会有很高的性能
    - TUN
      - tunneling隧道
      - CIP->DIP->RIP->CIP(在DIP发送到RIP时做了二次封装,RIP拿到包后要二次解析)
      - 响应流量不走lvs,同时DIP和RIP也不一定要在同一机房,但要求RS必须支持隧道模式即要二次解析IP包
  - 调度策略
    - 轮询/权重轮询
    - 最少连接/权重最少连接
    - ip_hash/ip_hash_group/url_hash/url_hash_group...
  - 优势
    - ip层的负载均衡,没有应用层回调的消耗，性能高
    - 通过DR/TUN模式使响应不走lvs
    - 支持后端心跳检测,自动故障转移恢复
    - 配合主从keepAlive和VIP实现自身高可用
- nginx
  - 功能
    - 请求解析(http/https)
    - 负载均衡(应用层)
    - 缓存调度
    - 授权认证
    - 接入处理(过滤非法请求)
    - 业务逻辑
    - 响应处理
    - 压缩技术
  - 职责分类
    - 接入层nginx
    - 应用层nginx(缓存调度/业务逻辑/限流降级)
  - 高性能原因
    - master-worker进程模型
      - master进程系统调用
        - socket()
        - bind()
        - listen()
        - fork()
      - worker进程系统调用
        - accept()
        - recv()
        - send()
        - close()
    - 异步模型
      - select(缺点:只能并发1024个请求/低效的遍历性能消耗)
      - epoll(linux2.6后实现的事件机制,解决了上面2个问题)
    - 流式处理请求workflow,有主子请求
    - 协程机制解决worker上不能有阻塞操作
      - 协程
        - 栈/局部变量在用户空间模拟，切换开销小
        - 协程间是协作关系
        - 临界区不需要加锁
        - 遇到阻塞主动放弃切换
      - 线程
        - 栈/局部变量是内核空间的映射，切换开销大
        - 多线程并发运行是竞争cpu关系
        - 临界区需要同步加锁
        - 遇到阻塞进入等待cpu切换
    - nginx lua
  - 具体应用
    - 负载均衡
      - upstream
      - proxy_pass
    - 代理缓存(先要有后端的代理才能使用代理缓存)
      - proxy_cache_path PATH levels=1:2 keys_zone=NAME:100m inactive=7d max_size=100g;
        - 把缓存文件放在PATH中
        - levels=1:2 缓存文件目录层级和目录名称长度
        - keys_zone 指定了一个内存空间，并设置大小来缓存key与缓存文件目录的映射关系
        - inactive=7d 缓存文件7天后失效淘汰
        - max_size=100g 缓存文件总大小超过100g后释放淘汰
      - 使用
        - proxy_cache NAME; # 使用缓存空间
        - proxy_cache_valid 200 206 302 304 10d; # 后端返回以下响应码时缓存多久
        - proxy_cache_key $uri; # 一般使用$uri作为缓存的key;

### 网关层
- 分布式会话管理
  - 会话机制
    - session
      - 通过判断SID里是否包含用户信息判定用户是否登陆
      - 依赖后端的session容器和前端的cookie，无法解决cookie跨域和禁用的问题
    - cookie
      - 后端验证用户信息后将凭证做数字签名，加密后写入cookie的ticket，验证时取出ticket解密判断
      - 不依赖后端session容器但也没有解决cookie跨域和禁用的问题
    - token
      - 后端验证用户信息后将凭证做数字签名，加密后写入token返回前端，前端请求时参数或header中携带token
      - 不依赖cookie，但需要请求时携带token
  - 安全问题
    - cookie被劫持，xss/csrf安全攻击
    - token凭证被劫持，伪造
  - 解决方式
    - https
    - 风控系统主动失效及过期机制
  - 分布式会话管理
    - 登陆凭证放入集中的会话管理redis/memcached
    - 对应session的处理机制要重写
- 接入层控制
  - 控制内容
    - 身份验证
      - 通过会话管理获取用户登陆凭证
      - 通过用户凭证获取用户信息
      - 验证对应的url/资源是否可以被用户访问
    - 流量控制
      - 对应url流量是否可以被承载否则限流(filter的pre/post进行计数即可实现)
      - 对应服务分级的流量是否被承载
      - 对应整个系统的总流量是否被承载
    - 路由服务
      - 根据url规则找到对应的服务
      - 判断服务的状态，做服务路由调用
    - 记录调试或统计信息
  - 通过接入层框架的通用的filter功能实现
    - javaServletFilter
    - springMVCHandlerInterceptor
    - zuulFilter
- 服务调用及聚合
  - 如果需要多个后端服务调用则需要在网关层这里做聚合
  - 分类
    - 重接入
      - springMVC+dubbo
      - 优点：可灵活的在controller层处理业务逻辑，聚合服务
      - 缺点：服务的单一性不够，后端服务不便管理
    - 轻接入
      - zuul
      - 优点：服务单一，接入控制可以页面配置
      - 缺点：聚合能力不够，需要后端提供

### 核心服务层之服务通信
- 微服务
  - 传统服务缺点
    - 所有服务耦合在一起
    - 隔离型弱，互相影响
    - 部署臃肿
    - 开发维护困难
  - 微服务
    - 特性
      - 高内聚,低耦合,专注自己的核心业务
      - 隔离型强,不会相互影响(进程上)
      - 轻量的通信机制
      - 独立开发,单独部署
    - 需要解决的问题
      - 服务治理(服务注册和发现,负载均衡和智能容错,服务监控和健康管理,限流降级熔断)
      - 数据一致性
      - 调用性能
      - 研发流程调试,部署,测试
- dubbo服务治理
  - 来解决微服务服务治理的轻量级开源javaRPC框架
  - 核心能力
    - 面向接口的远程方法调用
    - 服务自动注册和发现
    - 负载均衡和智能容错
- 异步消息服务
  - 分类
    - JMS(apacheActiveMQ)
    - Kafka(流式处理)
    - RocketMQ(alibaba基于Kafka开发的分布式一致性服务)
  - JMS
    - javaMessageService
    - 特点
      - 点对点(每个消息都被发送到特定的队列,接收者从队列中顺序消费,队列保留着消息直到被消费或超时)
      - 发布订阅(客户端将消息发到主题,消息队列存放主题,订阅者消费主题)
    - activeMQ缺点
      - 以消息为单位,为保证消息稳定性需要落盘,但可能落盘时不连续,磁盘寻值有性能问题
      - 消费时是推模式,对consumer的线程压力非常大
  - Kafka
    - 默认支持点对点，但不常用，常用发布订阅
    - 客户端将消息发到主题,消息队列存放主题,订阅者消费主题,消息持久化到队尾,消费通过客户端指针,吞吐量高
    - 比activeMQ优点
      - 引入broker概念把相同topic的消息连续的落到同一个文件,保证磁盘IO性能
      - 消费时是拉模式,根据consumer性能决定消费速度
      - 引入了nameServer类似zookeeper的组件和队列/失败重试队列来保证消息稳定可靠
  - RocketMQ
    - 结合了Kafka和ActiveMQ的优点,把Kafka很多的api封装成类似ActiveMQ简单易用
    - 消息队列维护高可用,并支持事务回溯机制(增加了prepare队列)